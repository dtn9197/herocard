"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
/* eslint-disable no-restricted-syntax */
const lru_cache_1 = tslib_1.__importDefault(require("lru-cache"));
const fs_1 = tslib_1.__importDefault(require("fs"));
const util_1 = require("util");
const utils_1 = require("../utils/utils");
const stat = util_1.promisify(fs_1.default.stat);
/**
 * Cache by user agent + file path, so that there can be unique transforms
 * per browser.
 */
function createCacheKey(ctx) {
    return `${ctx.get('user-agent')}${ctx.url}`;
}
async function getLastModified(path) {
    try {
        return (await stat(path)).mtimeMs;
    }
    catch (error) {
        return -1;
    }
}
/**
 * Returns 304 response for cacheable requests if etag matches
 */
function createResponseBodyCacheMiddleware(cfg) {
    /** @type {Map<String, String>} */
    const cacheKeysForFilePaths = new Map();
    const cache = new lru_cache_1.default({
        length: (e, key) => e.body.length + (key ? key.length : 0),
        max: 52428800,
        // don't call dispose on overwriting
        noDisposeOnSet: true,
        // remove file path -> url mapping when we are no longer caching it
        dispose(cacheKey) {
            for (const [filePath, cacheKeyForFilePath] of cacheKeysForFilePaths.entries()) {
                if (cacheKeyForFilePath === cacheKey) {
                    cacheKeysForFilePaths.delete(filePath);
                    return;
                }
            }
        },
    });
    // remove file from cache on change
    cfg.fileWatcher.addListener('change', e => {
        const cacheKey = cacheKeysForFilePaths.get(e);
        if (cacheKey) {
            cache.del(cacheKey);
        }
    });
    return async function responseBodyCacheMiddleware(ctx, next) {
        const cacheKey = createCacheKey(ctx);
        const cached = cache.get(cacheKey);
        if (cached) {
            // we watch files, and remove them on change, but there can be edge cases
            // where these events do not come through properly (the file system is a 'live' system)
            // we double check the last modified timestamp first
            if (cached.lastModified === (await getLastModified(cached.filePath))) {
                ctx.body = cached.body;
                ctx.response.set(cached.headers);
                ctx.status = 200;
                utils_1.logDebug(`Serving from response body cache: ${ctx.url}`);
                return;
            }
            // remove file from cache if it changed in the meantime, and serve regularly
            cache.del(cacheKey);
        }
        await next();
        if (ctx.method !== 'GET' || !ctx.body) {
            return;
        }
        if (ctx.status !== 200) {
            return;
        }
        if (utils_1.isGeneratedFile(ctx.url) || !ctx.response.is('js')) {
            return;
        }
        try {
            const body = await utils_1.getBodyAsString(ctx);
            const filePath = utils_1.getRequestFilePath(ctx, cfg.rootDir);
            if (!filePath) {
                return;
            }
            cacheKeysForFilePaths.set(filePath, ctx.url);
            cache.set(cacheKey, {
                body,
                headers: ctx.response.headers,
                filePath,
                lastModified: await getLastModified(filePath),
            });
            utils_1.logDebug(`Adding to response body cache: ${ctx.url}`);
        }
        catch (error) {
            if (error instanceof utils_1.RequestCancelledError) {
                return;
            }
            throw error;
        }
    };
}
exports.createResponseBodyCacheMiddleware = createResponseBodyCacheMiddleware;
//# sourceMappingURL=response-body-cache.js.map